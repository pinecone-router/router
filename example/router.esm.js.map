{
  "version": 3,
  "sources": ["../src/history.ts", "../src/context.ts", "../src/route.ts", "../src/settings.ts", "../src/errors.ts", "../src/utils.ts", "../src/templates.ts", "../src/handler.ts", "../src/router.ts", "../src/directives/x-template.ts", "../src/directives/x-handler.ts", "../src/directives/x-route.ts", "../src/links.ts", "../src/index.ts"],
  "sourcesContent": [
    "import { type PineconeRouter } from './router'\n\nexport interface NavigationHistory {\n\t/**\n\t * The current history index\n\t */\n\tindex: number\n\n\t/**\n\t * The list of history entries\n\t */\n\tentries: string[]\n\n\t/**\n\t * Check if the router can navigate backward\n\t * @returns {boolean} true if the router can go back\n\t */\n\tcanGoBack: () => boolean\n\n\t/**\n\t * Go back to the previous route in the navigation history\n\t */\n\tback: () => void\n\n\t/**\n\t * Check if the router can navigate forward\n\t *\n\t * @returns {boolean} true if the router can go forward\n\t */\n\tcanGoForward: () => boolean\n\n\t/**\n\t * Go to the next route in the navigation history\n\t */\n\tforward: () => void\n\n\t/**\n\t * Navigate to a specific position in the navigation history\n\t *\n\t * @param index The index of the navigation position to navigate to\n\t * @returns void\n\t */\n\tto: (index: number) => void\n\n\t/**\n\t * Push a new path to the history at the current index.\n\t * @internal\n\t * @param path The path to add to the history\n\t * @param pushState Whether or not to call History.pushState.\n\t *        Will be set to false if it's the first load or if it's called from\n\t *        a popstate event.\n\t * @param hash Whether or not we're using hash routing\n\t * @returns void\n\t */\n\tpush: (path: string, pushState: boolean, hash?: boolean) => void\n\n\t/**\n\t * Call History.pushState\n\t * @internal\n\t * @param path The path to add to the history\n\t * @param hash Whether or not we're using hash routing\n\t * @returns void\n\t */\n\tpushState: (path: string, hash?: boolean) => void\n\n\t/**\n\t * The router instance\n\t * @internal\n\t */\n\trouter?: PineconeRouter\n\n\t/**\n\t * Set the router instance\n\t * @internal\n\t * @param router The router instance to set\n\t */\n\tsetRouter: (router: PineconeRouter) => void\n}\n\nexport const createNavigationHistory = (): NavigationHistory => {\n\treturn {\n\t\tentries: [],\n\t\tindex: 0,\n\t\tcanGoBack: function (): boolean {\n\t\t\treturn this.index > 0\n\t\t},\n\n\t\tback: function (): void {\n\t\t\tthis.to(this.index - 1)\n\t\t},\n\n\t\tcanGoForward: function (): boolean {\n\t\t\treturn this.index < this.entries.length - 1\n\t\t},\n\n\t\tforward: function (): void {\n\t\t\tthis.to(this.index + 1)\n\t\t},\n\n\t\tto: function (index: number): void {\n\t\t\tif (index in this.entries) {\n\t\t\t\tthis.router?.navigate(this.entries[index], false, false, index)\n\t\t\t}\n\t\t},\n\n\t\tpush: function (path: string, pushState: boolean, hash?: boolean): void {\n\t\t\t// only update history if navigating to a different path\n\t\t\tif (this.index < this.entries.length - 1) {\n\t\t\t\t// trim navigation history if we're not at the end\n\t\t\t\tthis.entries = this.entries.slice(0, this.index + 1)\n\t\t\t}\n\t\t\t// add current path and update index\n\t\t\tthis.entries.push(path)\n\t\t\tthis.index = this.entries.length - 1\n\n\t\t\tif (pushState) this.pushState(path, hash)\n\t\t},\n\n\t\tpushState: function (path: string, hash?: boolean): void {\n\t\t\tconst fullPath = hash ? '#' + path : path\n\t\t\thistory.pushState({ path: fullPath }, '', fullPath)\n\t\t},\n\n\t\tsetRouter(router: PineconeRouter): void {\n\t\t\tthis.router = router\n\t\t},\n\t}\n}\n",
    "export const buildContext: contextBuilder = (path, params, route) => {\n\treturn {\n\t\tpath,\n\t\troute,\n\t\tparams,\n\t}\n}\n\ntype contextBuilder = (\n\tpath: string,\n\tparams: Context['params'],\n\troute: string\n) => Context\n\n/**\n * This is the global Context object\n * Which can be accessed from `PineconeRouter.context`\n */\nexport interface Context {\n\treadonly path: string\n\treadonly route: string\n\treadonly params: Record<string, string | undefined>\n}\n",
    "import type { Handler } from './handler'\nexport interface Route {\n\t/**\n\t * Set to true automatically when creating a route programmatically.\n\t * @internal\n\t */\n\treadonly programmaticTemplates: boolean\n\n\t/**\n\t * Set to true when the route is added programmatically and defined as having\n\t * params in the template urls\n\t * @internal\n\t */\n\treadonly interpolate: boolean\n\t/**\n\t * The regex pattern used to match the route.\n\t * @internal\n\t */\n\treadonly pattern: RegExp\n\t/**\n\t * The target ID for the route's templates\n\t */\n\treadonly targetID?: string\n\t/**\n\t * The raw route path\n\t */\n\treadonly path: string\n\n\tmatch(path: string): RouteArgs\n\thandlers: Handler<unknown, unknown>[]\n\ttemplates: string[]\n}\n\nexport interface RouteOptions {\n\thandlers?: Route['handlers']\n\tinterpolate?: boolean\n\ttemplates?: string[]\n\ttargetID?: string\n\tpreload?: boolean\n}\n\n/**\n * Creates a new Route object\n * @param {string} path - route path pattern\n * @param {RouteOptions} options - route configuration options\n * @returns {Route} - a route object\n */\nexport default function createRoute(\n\tpath: string,\n\t{\n\t\ttargetID,\n\t\ttemplates = [],\n\t\thandlers = [],\n\t\tinterpolate = false,\n\t}: RouteOptions = {}\n): Route {\n\t// Create the route object\n\tconst route: Route = {\n\t\tprogrammaticTemplates: templates.length > 0,\n\t\tpattern: parse(path),\n\t\tinterpolate,\n\t\ttemplates,\n\t\ttargetID,\n\t\thandlers,\n\t\tpath,\n\t\tmatch(path: string) {\n\t\t\tlet m = this.pattern.exec(path)\n\t\t\tif (m) {\n\t\t\t\treturn { ...m.groups }\n\t\t\t}\n\t\t},\n\t}\n\n\treturn route\n}\ntype RouteArgs = void | {\n\t[key: string]: string\n}\n\n/**\n * Based on [regexparam](https://github.com/lukeed/regexparam)\n * @param {string} input The route pattern\n * @returns {RegExp} The compiled regular expression for the route\n */\nexport function parse(input: string): RegExp {\n\tlet optionalIndex: number,\n\t\tsegment: string | undefined,\n\t\textensionIndex: number,\n\t\tpattern = ''\n\tconst segments = input.split('/')\n\tsegments[0] || segments.shift()\n\n\twhile ((segment = segments.shift())) {\n\t\tif (segment.startsWith(':')) {\n\t\t\toptionalIndex = segment.indexOf('?', 1)\n\t\t\textensionIndex = segment.indexOf('.', 1)\n\t\t\tlet paramName = segment.substring(\n\t\t\t\t1,\n\t\t\t\tMath.min(\n\t\t\t\t\t...[optionalIndex, extensionIndex, segment.length].filter(\n\t\t\t\t\t\t(i) => i > 0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\tconst isWildcard = paramName.endsWith('*') || paramName.endsWith('+')\n\t\t\tconst isOptionalWildcard = paramName.endsWith('*')\n\n\t\t\tif (isWildcard) {\n\t\t\t\tparamName = paramName.slice(0, -1)\n\t\t\t\tpattern += isOptionalWildcard\n\t\t\t\t\t? `(?:/(?<${paramName}>.*)?)?`\n\t\t\t\t\t: `/(?<${paramName}>.+)`\n\t\t\t} else {\n\t\t\t\tpattern +=\n\t\t\t\t\toptionalIndex > 0 && extensionIndex < 0\n\t\t\t\t\t\t? `(?:/(?<${paramName}>[^/]+?))?`\n\t\t\t\t\t\t: `/(?<${paramName}>[^/]+?)`\n\n\t\t\t\tif (extensionIndex > 0)\n\t\t\t\t\tpattern +=\n\t\t\t\t\t\t(optionalIndex > 0 ? '?' : '') +\n\t\t\t\t\t\t'\\\\' +\n\t\t\t\t\t\tsegment.substring(extensionIndex)\n\t\t\t}\n\t\t} else {\n\t\t\tpattern += '/' + segment\n\t\t}\n\t}\n\n\treturn new RegExp('^' + pattern + '\\/?$', 'i')\n}\n",
    "import type { Handler } from './handler'\n\nexport interface Settings {\n\t/**\n\t * enable hash routing\n\t * @default false: boolean\n\t */\n\thash: boolean\n\n\t/**\n\t * The base path of the site, for example /blog.\n\t * Note: do not use with using hash routing.\n\t * @default `/`\n\t */\n\tbasePath: string\n\n\t/**\n\t * Set an optional ID for where the templates will render by default.\n\t * This can be overriden by the .target modifier.\n\t * @default undefined\n\t */\n\ttargetID?: string\n\n\t/**\n\t * Set to false if you don't want to intercept link clicks by default.\n\t * @default true\n\t */\n\thandleClicks: boolean\n\n\t/**\n\t * Handlers that will run on every route.\n\t * @default []\n\t */\n\tglobalHandlers: Handler<unknown, unknown>[]\n\n\t/**\n\t * Set to true to preload all templates.\n\t * @default false\n\t * */\n\tpreload: boolean\n}\n\nexport let settings: Settings = {\n\thash: false,\n\tbasePath: '',\n\tglobalHandlers: [],\n\thandleClicks: true,\n\ttargetID: undefined,\n\tpreload: false,\n}\n\nexport const updateSettings = (value?: Partial<Settings>): Settings => {\n\tsettings = { ...settings, ...value }\n\treturn settings\n}\n",
    "import { ElementWithXAttributes } from 'alpinejs'\nimport { RouteTemplate } from './directives/x-route'\n\n/**\n * Centralized error messages\n */\n\nexport const INVALID_EXPRESSION_TYPE = (value: unknown) =>\n\t\t`Invalid expression type. Expression: ${value}.`,\n\tTARGET_ID_NOT_FOUND = (id: string) =>\n\t\t`Can't find an element with the supplied target ID: ${id}`,\n\tROUTE_EXISTS = (path: string) => `Route already exists: ${path}`,\n\tMISSING_TEMPLATE_TARGET = 'No target specified for template rendering',\n\tDIRECTIVE_REQUIRES_TEMPLATE =\n\t\t'Directives can only be used on template elements.',\n\tDIRECTIVE_REQUIRES_ROUTE = (directive: string) =>\n\t\t`x-${directive} must be used on the same template as x-route.`,\n\tTARGET_ID_NOT_SPECIFIED =\n\t\t'targetID must be specified for programmatically added templates.',\n\tROUTE_NOT_FOUND = (path: string) => `Path: ${path} was not found.`,\n\tTEMPLATE_PARAM_NOT_FOUND = (param: string, url: string) =>\n\t\t`The param ${param} in the template url ${url} does not exist.` as const\n\n/**\n * Assert functions\n */\n\n/**\n * Assert that the element is a template element with XAttributes\n * @param value HTMLElement\n */\nexport function assertTemplate(\n\tvalue: ElementWithXAttributes<HTMLElement>\n): asserts value is ElementWithXAttributes<HTMLTemplateElement> {\n\tif (value.tagName.toLowerCase() !== 'template') {\n\t\tthrow new TypeError(DIRECTIVE_REQUIRES_TEMPLATE)\n\t}\n}\n\n/**\n * Assert that the element is a template element with XAttributes and a route attribute\n * @param value {ElementWithXAttributes<HTMLElement>} The element to check\n */\nexport function assertRouteTemplate(\n\tvalue: ElementWithXAttributes<HTMLElement>\n): asserts value is RouteTemplate & { _x_PineconeRouter_route: string } {\n\tassertTemplate(value)\n\n\tif (value._x_PineconeRouter_route === undefined) {\n\t\tthrow new TypeError(DIRECTIVE_REQUIRES_ROUTE('template'))\n\t}\n}\n\n/**\n * Assert that the element is a template element with XAttributes and a route attribute\n * @param value {unknown} The evaluated expression to check\n */\nexport function assertExpressionIsArray(\n\tvalue: unknown\n): asserts value is unknown[] {\n\tif (typeof value != 'object' || !Array.isArray(value)) {\n\t\tthrow new TypeError(INVALID_EXPRESSION_TYPE(value))\n\t}\n}\n",
    "import { TARGET_ID_NOT_FOUND } from './errors'\n\nexport const modifierValue = (\n\tmodifiers: string[],\n\tkey: string,\n\tfallback?: string\n): string | undefined => {\n\t// If the modifier isn't present, use the default.\n\tif (modifiers.indexOf(key) === -1) return fallback\n\n\t// If it IS present, grab the value after it\n\tconst rawValue = modifiers[modifiers.indexOf(key) + 1]\n\n\tif (!rawValue) return fallback\n\n\tif (key === 'target') {\n\t\tlet match = rawValue.match(/([a-z0-9_-]+)/)\n\t\tif (match) return match[1]\n\t}\n\treturn rawValue\n}\n\nexport const addBasePath = (path: string, basePath: string) => {\n\tif (path == 'notfound') return path\n\n\tif (!path.startsWith(basePath)) {\n\t\tpath = basePath + path\n\t}\n\treturn path\n}\n\nexport const getTargetELement = (\n\ttargetId?: string,\n\tglobalTargetId?: string\n): HTMLElement | undefined => {\n\tlet target = targetId ?? globalTargetId ?? ''\n\tlet targetEl = document.getElementById(target)\n\n\tif (target.length && !targetEl)\n\t\tthrow new ReferenceError(TARGET_ID_NOT_FOUND(target))\n\n\treturn targetEl ?? undefined\n}\n",
    "import { type ElementWithXAttributes, type Alpine } from 'alpinejs'\n\nimport { type Context } from './context'\nimport { settings } from './settings'\nimport { addBasePath } from './utils'\n\nconst inMakeProgress = new Set()\nconst cache = new Map<string, string>()\nconst loading = new Map<string, Promise<string>>()\nconst preloads = new Set<{ urls: string[]; el?: HTMLElement }>()\n\nexport const fetchError = (error: string, url: string) => {\n\tdocument.dispatchEvent(\n\t\tnew CustomEvent('pinecone:fetch-error', { detail: { error, url } })\n\t)\n}\n\n// This function takes a template element and inserts its content right after\n// the element, or alternatively if  targetEl is it then inside of the latter.\nexport const make = (\n\tAlpine: Alpine,\n\ttemplate: ElementWithXAttributes<HTMLTemplateElement>,\n\texpression: string, // the expression on the x-template directive\n\ttargetEl?: HTMLElement,\n\turls?: string[]\n) => {\n\t// having a unique id ensures the same template can be used multiple times\n\t// inside the same page.\n\t// this is for when routes share a template.\n\t// with this, adding an id to the template element will make it unique.\n\tconst unique_id = template.id + expression\n\n\tif (inMakeProgress.has(unique_id)) return\n\tinMakeProgress.add(unique_id)\n\n\tconst contentNode = template.content\n\n\tconst clones: HTMLElement[] = Array(contentNode.childElementCount)\n\n\t// Clone scripts to make them run\n\tcontentNode.querySelectorAll('script').forEach((oldScript) => {\n\t\tconst newScript = document.createElement('script')\n\t\tArray.from(oldScript.attributes).forEach((attr) =>\n\t\t\tnewScript.setAttribute(attr.name, attr.value)\n\t\t)\n\t\tnewScript.textContent = oldScript.textContent\n\t\toldScript.parentNode?.replaceChild(newScript, oldScript)\n\t})\n\n\t// Clone all children and add the x-data scope\n\tArray.from(contentNode.children).forEach((child, index) => {\n\t\tconst clone = child.cloneNode(true) as ElementWithXAttributes<HTMLElement>\n\t\tclones[index] = clone\n\t\tAlpine.addScopeToNode(clone, {}, template)\n\t\t// TODO: add if proved useful\n\t\t// template.id && clone.setAttribute('template-id', template.id)\n\t})\n\n\tAlpine.mutateDom(() => {\n\t\tif (targetEl) {\n\t\t\ttargetEl.replaceChildren(...clones)\n\t\t} else template.after(...clones)\n\t\tclones.forEach((clone) => {\n\t\t\tAlpine.initTree(clone)\n\t\t})\n\t})\n\n\ttemplate._x_PineconeRouter_template = clones\n\t// keep track of the currently rendered template urls\n\ttemplate._x_PineconeRouter_templateUrls = urls\n\n\ttemplate._x_PineconeRouter_undoTemplate = () => {\n\t\t// Remove clone element\n\t\tAlpine.mutateDom(() => {\n\t\t\tclones.forEach((clone: ElementWithXAttributes<HTMLElement>) => {\n\t\t\t\tAlpine.destroyTree(clone)\n\t\t\t\tclone.remove()\n\t\t\t})\n\t\t})\n\n\t\tdelete template._x_PineconeRouter_template\n\t\tdelete template._x_PineconeRouter_templateUrls\n\t}\n\n\tAlpine.nextTick(() => inMakeProgress.delete(unique_id))\n}\n\n// Hide content of a template element\nexport const hide = (template: ElementWithXAttributes<HTMLTemplateElement>) => {\n\tif (template._x_PineconeRouter_undoTemplate) {\n\t\ttemplate._x_PineconeRouter_undoTemplate()\n\t\tdelete template._x_PineconeRouter_undoTemplate\n\t}\n}\n\nexport const show = async (\n\tAlpine: Alpine,\n\ttemplate: ElementWithXAttributes<HTMLTemplateElement>,\n\texpression: string,\n\turls?: Array<string>,\n\ttargetEl?: HTMLElement\n) => {\n\t// case: template already rendered, params changed.\n\t// if the template is rendered but the template url parameters have changed\n\t// hide the content and remove the content inside the template\n\t// this will trigger the template to be loaded again with new urls bellow.\n\tif (\n\t\ttemplate._x_PineconeRouter_templateUrls != undefined &&\n\t\ttemplate._x_PineconeRouter_templateUrls != urls\n\t) {\n\t\thide(template)\n\t\ttemplate.innerHTML = ''\n\t}\n\n\t// case: template already rendered, route didn't change.\n\t// the template is already inserted into the page\n\t// leave it as is and return.\n\tif (template._x_PineconeRouter_template) {\n\t\treturn\n\t}\n\n\t// case: template not rendered, but template content exists.\n\tif (template.content.childElementCount) {\n\t\tmake(Alpine, template, expression, targetEl, urls)\n\t\treturn\n\t}\n\n\t// case: template content doesn't exist, load it from urls\n\tif (urls) {\n\t\t// if templates are not loaded, load them\n\t\treturn load(urls, template).then(() =>\n\t\t\tmake(Alpine, template, expression, targetEl, urls)\n\t\t)\n\t}\n}\n\n// Process params inside template urls\nexport const interpolate = (\n\turls: string[],\n\tparams: Context['params']\n): string[] => {\n\treturn urls.map((url) =>\n\t\turl.replace(/:([^/.]+)/g, (_, name) => params[name] || name)\n\t)\n}\n\n// Load a template from a url and put its content into cachedTemplates\nexport const loadUrl = async (\n\turl: string,\n\tpriority: RequestPriority = 'high'\n): Promise<string> => {\n\turl = addBasePath(url, settings.basePath)\n\t// Return from cache if available\n\tif (cache.has(url)) return cache.get(url)!\n\n\t// Return existing promise if already loading\n\tif (loading.has(url)) return loading.get(url)!\n\n\tconst fetchPromise = fetch(url, { priority })\n\t\t.then((r) => {\n\t\t\tif (!r.ok) {\n\t\t\t\tfetchError(r.statusText, url)\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\treturn r.text()\n\t\t})\n\t\t.then((html) => {\n\t\t\tif (html) cache.set(url, html)\n\t\t\tloading.delete(url)\n\t\t\treturn html || ''\n\t\t})\n\n\tloading.set(url, fetchPromise)\n\treturn fetchPromise\n}\n\n// Preload templates from urls\nexport const preload = (urls: string[], el?: HTMLElement): void => {\n\tpreloads.add({ urls, el })\n}\n\nexport const runPreloads = (): void => {\n\tfor (const item of preloads) {\n\t\tif (item.el) {\n\t\t\tload(item.urls, item.el, 'low')\n\t\t} else {\n\t\t\titem.urls.map((url) => loadUrl(url, 'low'))\n\t\t}\n\t\tpreloads.delete(item)\n\t}\n}\n\n/**\n * Load templates from urls into an element\n * @param urls array of urls to load\n * @param el target element where to put the content of the urls\n * @returns Promise<string> the new innerHTML of the target element\n */\nexport const load = (\n\turls: string[],\n\tel: HTMLTemplateElement | HTMLElement,\n\tpriority: RequestPriority = 'high'\n): Promise<void> =>\n\tPromise.all(urls.map((url) => loadUrl(url, priority))).then((htmlArray) => {\n\t\tel.innerHTML = htmlArray.join('')\n\t})\n",
    "import { Context } from './context'\nimport { Route } from './route'\n/**\n * Handler type takes the In and Out parameters.\n *\n * @param In  is the value of the previous handler, which will be inside\n * `HandlerContext.data`.\n * @param Out is the return value of the handler.\n */\nexport type Handler<In, Out> = (\n\tcontext: HandlerContext<In>,\n\tcontroller: AbortController\n) => Out | Promise<Out>\n\n/**\n * HandlerContext is the context passed to the handler.\n * It contains the current route and the data from the previous handler.\n */\nexport interface HandlerContext<T = unknown> extends Context {\n\treadonly data: T\n}\n\n/**\n * Execute route handlers sequentially, with cancellation support\n * @param handlers handlers to execute\n * @param context current context\n * @param controller abort controller\n * @returns {Promise<void>}\n */\nexport async function handle(\n\thandlers: Route['handlers'],\n\tcontext: Context,\n\tcontroller: AbortController\n): Promise<void> {\n\tlet data: unknown\n\t// Return a promise that rejects when aborted\n\treturn new Promise<void>(async (resolve, reject) => {\n\t\tcontroller.signal.addEventListener('abort', () => reject())\n\t\tfor (const handler of handlers) {\n\t\t\t// Check if aborted before running each handler\n\t\t\tif (controller.signal.aborted) return\n\t\t\tconst ctx = { ...context, data } as HandlerContext<\n\t\t\t\tParameters<typeof handler>[0]\n\t\t\t>\n\t\t\t// try catch abort signal from the handler if the user used promise with\n\t\t\t// abort signal.\n\t\t\ttry {\n\t\t\t\tdata = await handler(ctx, controller)\n\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t}\n\t\tresolve()\n\t})\n}\n",
    "import { type Alpine } from 'alpinejs'\n\nimport { createNavigationHistory, type NavigationHistory } from './history'\nimport { buildContext, type Context } from './context'\nimport createRoute, { type Route, type RouteOptions } from './route'\nimport { settings, updateSettings, type Settings } from './settings'\nimport { interpolate, load, preload } from './templates'\nimport { addBasePath } from './utils'\nimport { handle } from './handler'\nimport {\n\tTARGET_ID_NOT_SPECIFIED,\n\tROUTE_NOT_FOUND,\n\tROUTE_EXISTS,\n} from './errors'\n\n// Create a custom type that guarantees the notfound route exists\nexport type RoutesMap = Map<string, Route> & {\n\tget(key: 'notfound'): Route\n}\n\nexport interface PineconeRouter {\n\treadonly name: string\n\treadonly version: string\n\n\troutes: RoutesMap\n\tcontext: Context\n\tsettings: (value?: Partial<Settings>) => Settings\n\thistory: NavigationHistory\n\n\tloading: boolean\n\n\t/**\n\t * Add a new route\n\t *\n\t * @param {string} path the path to match\n\t * @param {RouteOptions} options the options for the route\n\t */\n\tadd: (path: string, options: RouteOptions) => void\n\n\t/**\n\t * Remove a route\n\t *\n\t * @param {string} path the route to remove\n\t */\n\tremove: (path: string) => void\n\n\t/**\n\t *  Navigate to the specified path\n\t *\n\t * @param {string} path the path with no hash even if using hash routing\n\t * @param {boolean} fromPopState INTERNAL Is set to true when called from\n\t *                  onpopstate event\n\t * @param {boolean} firstLoad INTERNAL Is set to true on browser page load.\n\t * @param {number} index INTERNAL the index of the navigation history\n\t *                  that was navigated to.\n\t * @returns {Promise<void>}\n\t */\n\tnavigate: (\n\t\tpath: string,\n\t\tfromPopState?: boolean,\n\t\tfirstLoad?: boolean,\n\t\tindex?: number\n\t) => Promise<void>\n}\n\nexport const createPineconeRouter = (\n\tAlpine: Alpine,\n\tname: string,\n\tversion: string\n): PineconeRouter => {\n\tconst notfound = createRoute('notfound', {\n\t\thandlers: [\n\t\t\t(ctx) => console.error(new ReferenceError(ROUTE_NOT_FOUND(ctx.path))),\n\t\t],\n\t})\n\n\tconst routes = new Map([['notfound', notfound]]) as RoutesMap\n\n\tconst context = buildContext('', {}, '')\n\tlet controller: AbortController | null = null\n\tlet loading = false\n\n\tconst router: PineconeRouter = {\n\t\tname,\n\t\tversion,\n\t\thistory: createNavigationHistory(),\n\t\troutes,\n\t\tcontext,\n\n\t\tget loading(): boolean {\n\t\t\treturn loading\n\t\t},\n\n\t\tset loading(value) {\n\t\t\tif (loading == value) return\n\t\t\tloading = value\n\t\t\tdocument.dispatchEvent(\n\t\t\t\tnew Event(value ? 'pinecone:start' : 'pinecone:end')\n\t\t\t)\n\t\t},\n\n\t\tsettings: (value) => updateSettings(value),\n\n\t\tadd: function (path, options) {\n\t\t\t// check if the route was registered already\n\t\t\t// but allow updating the notfound route\n\t\t\tif (path != 'notfound') {\n\t\t\t\tpath = addBasePath(path, settings.basePath)\n\t\t\t\tif (this.routes.has(path)) {\n\t\t\t\t\tthrow new Error(ROUTE_EXISTS(path))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// preload if specified globally or in the route options\n\t\t\tif (options.templates && (settings.preload || options.preload)) {\n\t\t\t\tpreload(options.templates)\n\t\t\t}\n\n\t\t\tthis.routes.set(path, createRoute(path, options))\n\t\t},\n\n\t\tremove: function (path) {\n\t\t\tthis.routes.delete(path)\n\t\t},\n\n\t\tnavigate: async function (path, fromPopState?, firstLoad?, index?) {\n\t\t\t// Cancel any ongoing handlers\n\t\t\tif (controller) {\n\t\t\t\tcontroller.abort()\n\t\t\t}\n\t\t\t// Create a new controller for this navigation\n\t\t\tcontroller = new AbortController()\n\n\t\t\t// if specified add the basePath\n\n\t\t\tpath = addBasePath(path || '/', settings.basePath)\n\n\t\t\t// special case: first load with hash routing and root path\n\t\t\t// if (firstLoad && settings.hash && path === '/') {\n\t\t\t// \treturn this.navigate('/', false, false)\n\t\t\t// }\n\n\t\t\tlet route = this.routes.get('notfound')\n\t\t\tlet params = {}\n\n\t\t\tfor (let [_, r] of this.routes) {\n\t\t\t\tconst res = r.match(path)\n\t\t\t\tif (res) {\n\t\t\t\t\tparams = res\n\t\t\t\t\troute = r\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create a new local context object.\n\t\t\t// this is to prevent editing the global context, which triggers\n\t\t\t// Alpine effects and causes them to run before this function has\n\t\t\t// done its work.\n\t\t\tconst context = buildContext(path, params, route.path)\n\n\t\t\tconst handlers = settings.globalHandlers.concat(route.handlers)\n\n\t\t\tthis.loading = true\n\n\t\t\tif (handlers.length) {\n\t\t\t\t// try catch promise reject from abort signal\n\t\t\t\ttry {\n\t\t\t\t\tawait handle(handlers, context, controller)\n\t\t\t\t} catch (_) {\n\t\t\t\t\t// promise rejected by abort signal\n\t\t\t\t\tthis.loading = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (!route.templates) {\n\t\t\t\t\tthis.loading = false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index != null) {\n\t\t\t\t// if called from history.to(), do not push to the NavigationHistory.\n\t\t\t\t// only call History.pushState() to update the URL\n\t\t\t\tthis.history.index = index\n\t\t\t\tthis.history.pushState(path, settings.hash)\n\t\t\t} else if (path != this.context.path) {\n\t\t\t\t// if this was non-history navigation, and  path has changed,\n\t\t\t\t//  push the path to the NavigationHistory\n\t\t\t\tthis.history.push(path, !fromPopState && !firstLoad, settings.hash)\n\t\t\t}\n\n\t\t\t// update the global context, trigger Alpine effect, and render templates.\n\t\t\tthis.context = context\n\n\t\t\t// show templates added programmatically\n\t\t\tif (route.programmaticTemplates) {\n\t\t\t\tlet target = document.getElementById(\n\t\t\t\t\troute.targetID ?? settings.targetID ?? ''\n\t\t\t\t)\n\n\t\t\t\tif (!target) throw new Error(TARGET_ID_NOT_SPECIFIED)\n\t\t\t\tconst urls = route.interpolate\n\t\t\t\t\t? interpolate(route.templates, params)\n\t\t\t\t\t: route.templates\n\n\t\t\t\tload(urls, target).finally(() => (this.loading = false))\n\t\t\t}\n\n\t\t\t// end loading if there are no templates\n\t\t\tif (!route.templates) this.loading = false\n\t\t},\n\t}\n\n\trouter.history.setRouter(router)\n\treturn router\n}\n",
    "import { type Alpine } from 'alpinejs'\n\nimport { assertExpressionIsArray, assertRouteTemplate } from '../errors'\nimport { hide, interpolate, preload, show } from '../templates'\nimport { getTargetELement, modifierValue } from '../utils'\nimport { PineconeRouter } from '../router'\nimport { settings } from '../settings'\n\nconst TemplateDirective = (Alpine: Alpine, Router: PineconeRouter) => {\n\tAlpine.directive(\n\t\t'template',\n\t\t(el, { expression, modifiers }, { evaluate, cleanup, Alpine, effect }) => {\n\t\t\tassertRouteTemplate(el)\n\n\t\t\tconst targetEl = getTargetELement(\n\t\t\t\tmodifierValue(modifiers, 'target'),\n\t\t\t\tsettings.targetID\n\t\t\t)\n\n\t\t\tconst path = el._x_PineconeRouter_route\n\t\t\tlet urls: string[]\n\t\t\tconst interpolated = modifiers.includes('interpolate')\n\n\t\t\t// only process the expression if it is not empty\n\t\t\t// this allows inline templates to be used without an expression\n\n\t\t\tif (expression != '') {\n\t\t\t\texpression = expression.trim()\n\t\t\t\tif (\n\t\t\t\t\t!(expression.startsWith('[') && expression.endsWith(']')) &&\n\t\t\t\t\t!(expression.startsWith('Array') && expression.endsWith(')'))\n\t\t\t\t) {\n\t\t\t\t\texpression = `['${expression}']`\n\t\t\t\t}\n\n\t\t\t\tconst evaluatedExpression = evaluate(expression)\n\t\t\t\tassertExpressionIsArray(evaluatedExpression)\n\t\t\t\turls = evaluatedExpression as string[]\n\n\t\t\t\tif (\n\t\t\t\t\t!interpolated &&\n\t\t\t\t\t(settings.preload || modifiers.includes('preload'))\n\t\t\t\t) {\n\t\t\t\t\tpreload(urls, el)\n\t\t\t\t}\n\n\t\t\t\tconst route = Router.routes.get(path)!\n\t\t\t\troute.templates = urls\n\t\t\t}\n\n\t\t\tconst callback = (urls?: string[]) => {\n\t\t\t\tconst found = Router.context.route === path\n\t\t\t\tif (found) {\n\t\t\t\t\tif (urls && interpolated) {\n\t\t\t\t\t\turls = interpolate(urls, Router.context.params)\n\t\t\t\t\t}\n\t\t\t\t\tshow(Alpine, el, expression, urls, targetEl).then(() => {\n\t\t\t\t\t\tRouter.loading = false\n\t\t\t\t\t})\n\t\t\t\t} else hide(el)\n\t\t\t}\n\n\t\t\teffect(() => callback(urls))\n\n\t\t\tcleanup(() => {\n\t\t\t\tel._x_PineconeRouter_undoTemplate && el._x_PineconeRouter_undoTemplate()\n\t\t\t})\n\t\t}\n\t)\n}\n\nexport default TemplateDirective\n",
    "import { type Alpine } from 'alpinejs'\nimport { PineconeRouter } from '../router'\nimport { assertExpressionIsArray, assertRouteTemplate } from '../errors'\n\nimport { type Route } from '../route'\nimport type { Handler } from '../handler'\n\nconst HandlerDirective = (Alpine: Alpine, Router: PineconeRouter) => {\n\tAlpine.directive(\n\t\t'handler',\n\t\t(el, { expression, modifiers }, { evaluate, cleanup }) => {\n\t\t\t// check if the handlers expression is an array\n\t\t\t// if not make it one\n\t\t\texpression = expression.trim()\n\t\t\tif (\n\t\t\t\t!(expression.startsWith('[') && expression.endsWith(']')) &&\n\t\t\t\t!(expression.startsWith('Array') && expression.endsWith(')'))\n\t\t\t) {\n\t\t\t\texpression = `[${expression}]`\n\t\t\t}\n\n\t\t\tconst evaluatedExpression = evaluate(expression)\n\n\t\t\tassertExpressionIsArray(evaluatedExpression)\n\n\t\t\tlet handlers = evaluatedExpression as Handler<unknown, unknown>[]\n\n\t\t\t// add `this` context for handlers inside an Alpine.component\n\t\t\tfor (let i = 0; i < handlers.length; i++) {\n\t\t\t\thandlers[i] = handlers[i].bind(Alpine.$data(el))\n\t\t\t}\n\n\t\t\tlet route: Route\n\n\t\t\tif (modifiers.includes('global')) {\n\t\t\t\tRouter.settings.globalHandlers = handlers\n\t\t\t} else {\n\t\t\t\tassertRouteTemplate(el)\n\n\t\t\t\t// add handlers to the route\n\t\t\t\tlet path = el._x_PineconeRouter_route\n\t\t\t\troute = Router.routes.get(path)!\n\t\t\t\troute.handlers = handlers\n\t\t\t}\n\n\t\t\tcleanup(() => {\n\t\t\t\tif (modifiers.includes('global')) {\n\t\t\t\t\tRouter.settings.globalHandlers = []\n\t\t\t\t} else {\n\t\t\t\t\troute.handlers = []\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t).before('template')\n}\n\nexport default HandlerDirective\n",
    "import { type ElementWithXAttributes, type Alpine } from 'alpinejs'\n\nimport { PineconeRouter } from '../router'\nimport { assertTemplate } from '../errors'\nimport { addBasePath } from '../utils'\nimport { settings } from '../settings'\n\nexport interface RouteTemplate\n\textends ElementWithXAttributes<HTMLTemplateElement> {\n\t_x_PineconeRouter_route: string\n}\n\nconst RouteDirective = (Alpine: Alpine, Router: PineconeRouter) => {\n\tAlpine.directive('route', (el, { expression }, { cleanup }) => {\n\t\tlet path = addBasePath(expression, settings.basePath)\n\n\t\tassertTemplate(el)\n\n\t\tif (path != 'notfound') {\n\t\t\t// register the new route if possible\n\t\t\tRouter.add(path, {})\n\t\t}\n\n\t\t// set the path in the element so it is used by other directives\n\t\tel._x_PineconeRouter_route = path\n\n\t\tcleanup(() => {\n\t\t\tRouter.routes.delete(path)\n\t\t\tdelete el._x_PineconeRouter_route\n\t\t})\n\t}).before('handler')\n}\n\nexport default RouteDirective\n",
    "import { type PineconeRouter } from './router'\n\n/**\n * @description Add a handler to click events on valid links\n */\nexport const handleClicks = (Router: PineconeRouter) => {\n\twindow.document.body.addEventListener('click', (e: MouseEvent) => {\n\t\t// Ignore modified clicks or non-primary buttons\n\t\tif (\n\t\t\te.ctrlKey ||\n\t\t\te.metaKey ||\n\t\t\te.altKey ||\n\t\t\te.shiftKey ||\n\t\t\te.button ||\n\t\t\te.defaultPrevented\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\t// Find closest anchor element\n\t\tconst node = (e.target as HTMLElement).closest('a')\n\t\tif (!node) return\n\n\t\t// Skip if link shouldn't be intercepted\n\t\tif (\n\t\t\t(Router.settings.handleClicks === false &&\n\t\t\t\t!node.hasAttribute('x-link')) ||\n\t\t\tnode.hasAttribute('data-native') ||\n\t\t\tnode.hasAttribute('native')\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tconst href = node.getAttribute('href')\n\t\tconst target = node.getAttribute('target')\n\n\t\t// Only handle internal links without special targets\n\t\tif (href && (!target || /^_?self$/i.test(target))) {\n\t\t\tRouter.navigate(href)\n\t\t\te.preventDefault()\n\t\t}\n\t})\n}\n",
    "import { type PluginCallback, type Alpine } from 'alpinejs'\n\nimport { createPineconeRouter, type PineconeRouter } from './router'\nimport TemplateDirective from './directives/x-template'\nimport HandlerDirective from './directives/x-handler'\nimport RouteDirective from './directives/x-route'\nimport { type NavigationHistory } from './history'\nimport { runPreloads } from './templates'\nimport { type Context } from './context'\nimport { handleClicks } from './links'\n\nimport { name, version } from '../package.json'\nimport { settings } from './settings'\n\ndeclare global {\n\tinterface Window {\n\t\tPineconeRouter: PineconeRouter\n\t\tAlpine: Alpine\n\t}\n}\n\n// This extends the alpinejs types\n// Adding our custom magics and html attributes\n// This allows the user to extend AlpineComponent with $router and $params already set\ndeclare module 'alpinejs' {\n\tinterface XAttributes {\n\t\t_x_PineconeRouter_templateUrls: string[]\n\t\t_x_PineconeRouter_template: HTMLElement[]\n\t\t_x_PineconeRouter_scripts: HTMLScriptElement[]\n\t\t_x_PineconeRouter_undoTemplate: () => void\n\t\t_x_PineconeRouter_route: string\n\t}\n\n\tinterface Magics<T> {\n\t\t$router: PineconeRouter\n\t\t$stack: NavigationHistory\n\t\t$params: Context['params']\n\t}\n\n\tinterface Alpine {\n\t\t$router: PineconeRouter\n\t}\n}\n\nconst PineconeRouterPlugin: PluginCallback = function (Alpine: Alpine) {\n\tconst Router = Alpine.reactive(createPineconeRouter(Alpine, name, version))\n\n\twindow.PineconeRouter = Router\n\n\t// Initialize event listeners (equivalent to constructor)\n\tdocument.addEventListener('alpine:initialized', () => {\n\t\t// virtually navigate to the path on the first page load\n\t\t// this will register the path in history and sets the path variable\n\t\tif (settings.hash == false) {\n\t\t\tRouter.navigate(location.pathname + location.search, false, true)\n\t\t} else {\n\t\t\tRouter.navigate(location.hash.substring(1), false, true)\n\t\t}\n\t})\n\n\t// handle navigation events not emitted by links, for example, back button.\n\twindow.addEventListener('popstate', () => {\n\t\tif (settings.hash) {\n\t\t\tif (window.location.hash != '') {\n\t\t\t\tRouter.navigate(window.location.hash.substring(1), true)\n\t\t\t}\n\t\t} else {\n\t\t\tRouter.navigate(window.location.pathname, true)\n\t\t}\n\t})\n\n\t// intercept click event in links\n\thandleClicks(Router)\n\n\t// run preloads once when page fully loads.\n\tdocument.addEventListener(\n\t\t'pinecone:end',\n\t\t() => Alpine.nextTick(runPreloads),\n\t\t{\n\t\t\tonce: true,\n\t\t}\n\t)\n\n\t// order matters in order to use directive.before()\n\t// this makes sure the order is as follows:\n\t// x-route -> x-handler -> x-template\n\tTemplateDirective(Alpine, Router)\n\tHandlerDirective(Alpine, Router)\n\tRouteDirective(Alpine, Router)\n\n\tAlpine.$router = Router\n\n\tAlpine.magic('router', () => Router)\n\tAlpine.magic('history', () => Router.history)\n\tAlpine.magic('params', () => Router.context.params)\n}\n\nexport default PineconeRouterPlugin\n"
  ],
  "mappings": "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",
  "debugId": "7BABBCA4C6092E2264756E2164756E21",
  "names": []
}